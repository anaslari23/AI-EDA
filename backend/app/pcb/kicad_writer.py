"""KiCad Schematic Writer — Generate .kicad_sch files.

Produces a KiCad 6+ schematic file from a CircuitGraph with:
  - Symbol placement on a grid
  - Wire connections between pins
  - Power symbols for VCC/GND
  - Proper reference designators and values

Pure Python. Deterministic. No AI.
"""

from __future__ import annotations

import uuid
from io import StringIO
from typing import TextIO

from app.schemas.circuit import CircuitGraph, CircuitNode, CircuitEdge
from app.pcb.netlist_generator import get_ref_map, _footprint


# ─── Layout Geometry ───

GRID_PITCH_MM = 2.54  # Standard KiCad grid
SYMBOL_WIDTH_MM = 15.0
SYMBOL_HEIGHT_MM = 20.0
COL_SPACING_MM = 40.0
ROW_SPACING_MM = 35.0
SHEET_WIDTH_MM = 297.0  # A3
SHEET_HEIGHT_MM = 210.0
PIN_PITCH_MM = 2.54


class SymbolPlacement:
    """Calculated position for a symbol on the schematic."""

    __slots__ = ("node_id", "ref", "part", "x", "y", "pins")

    def __init__(
        self,
        node_id: str,
        ref: str,
        part: str,
        x: float,
        y: float,
        pins: list[str],
    ):
        self.node_id = node_id
        self.ref = ref
        self.part = part
        self.x = x
        self.y = y
        self.pins = pins


def _compute_layout(
    graph: CircuitGraph,
    ref_map: dict[str, str],
) -> list[SymbolPlacement]:
    """Place symbols in a grid layout ordered by type:
    regulators → MCUs → sensors → passives → protection.
    """
    type_order = {
        "regulator": 0,
        "mcu": 1,
        "sensor": 2,
        "passive": 3,
        "protection": 4,
        "connector": 5,
    }
    sorted_nodes = sorted(
        graph.nodes,
        key=lambda n: type_order.get(n.type, 9),
    )

    # Calculate grid dimensions
    max_cols = max(1, int((SHEET_WIDTH_MM - 40) // COL_SPACING_MM))
    start_x = 30.0
    start_y = 30.0

    placements: list[SymbolPlacement] = []
    for i, node in enumerate(sorted_nodes):
        col = i % max_cols
        row = i // max_cols
        placements.append(
            SymbolPlacement(
                node_id=node.id,
                ref=ref_map[node.id],
                part=node.part_number,
                x=start_x + col * COL_SPACING_MM,
                y=start_y + row * ROW_SPACING_MM,
                pins=node.pins,
            )
        )

    return placements


def _pin_position(
    placement: SymbolPlacement,
    pin_name: str,
    side: str = "auto",
) -> tuple[float, float]:
    """Calculate absolute pin position on the schematic.

    Left-side pins: power/ground/input.
    Right-side pins: output/signal/bidirectional.
    """
    pin_index = 0
    left_pins: list[str] = []
    right_pins: list[str] = []

    for p in placement.pins:
        upper = p.upper()
        if upper in ("VCC", "VIN", "GND") or upper.startswith("P"):
            left_pins.append(p)
        else:
            right_pins.append(p)

    if pin_name in left_pins:
        idx = left_pins.index(pin_name)
        return (
            placement.x,
            placement.y + 8.0 + idx * PIN_PITCH_MM,
        )
    elif pin_name in right_pins:
        idx = right_pins.index(pin_name)
        return (
            placement.x + SYMBOL_WIDTH_MM,
            placement.y + 8.0 + idx * PIN_PITCH_MM,
        )
    else:
        # Fallback: place sequentially on left
        pin_index = placement.pins.index(pin_name) if pin_name in placement.pins else 0
        return (
            placement.x,
            placement.y + 8.0 + pin_index * PIN_PITCH_MM,
        )


# ─── KiCad Schematic Writer ───


def generate_kicad_sch(graph: CircuitGraph) -> str:
    """Generate a KiCad 6+ schematic file content."""
    buf = StringIO()
    _write_kicad_sch(graph, buf)
    return buf.getvalue()


def write_kicad_sch_file(graph: CircuitGraph, path: str) -> None:
    """Write .kicad_sch to file."""
    content = generate_kicad_sch(graph)
    with open(path, "w") as f:
        f.write(content)


def _write_kicad_sch(graph: CircuitGraph, out: TextIO) -> None:
    """Write complete .kicad_sch S-expression."""
    ref_map = get_ref_map(graph)
    placements = _compute_layout(graph, ref_map)
    placement_map = {p.node_id: p for p in placements}

    sch_uuid = str(uuid.uuid4())

    # ─ Header
    out.write("(kicad_sch\n")
    out.write("  (version 20230121)\n")
    out.write('  (generator "antigravity_eda")\n')
    out.write(f'  (uuid "{sch_uuid}")\n')
    out.write("  (paper A3)\n\n")

    # ─ Title block
    out.write("  (title_block\n")
    out.write('    (title "ANTIGRAVITY AI EDA — Auto-Generated Schematic")\n')
    out.write('    (company "ANTIGRAVITY")\n')
    out.write('    (comment 1 "Generated by ANTIGRAVITY AI EDA Pipeline")\n')
    out.write("  )\n\n")

    # ─ Symbol instances
    for placement in placements:
        node = next(n for n in graph.nodes if n.id == placement.node_id)
        _write_symbol(out, node, placement)

    # ─ Wires (connections between pins)
    for edge in graph.edges:
        src_place = placement_map.get(edge.source_node)
        tgt_place = placement_map.get(edge.target_node)
        if not src_place or not tgt_place:
            continue
        _write_wire(out, edge, src_place, tgt_place)

    # ─ Power symbols
    _write_power_symbols(out, graph, placements)

    out.write(")\n")


def _write_symbol(
    out: TextIO,
    node: CircuitNode,
    placement: SymbolPlacement,
) -> None:
    """Write a single schematic symbol."""
    sym_uuid = str(uuid.uuid4())

    out.write("  (symbol\n")
    out.write(f'    (lib_id "antigravity:{node.type}")\n')
    out.write(f"    (at {placement.x:.2f} {placement.y:.2f} 0)\n")
    out.write(f'    (uuid "{sym_uuid}")\n')

    # Reference
    out.write("    (property Reference\n")
    out.write(f'      (value "{placement.ref}")\n')
    out.write(f"      (at {placement.x + 2:.2f} {placement.y - 3:.2f} 0)\n")
    out.write("      (effects (font (size 1.27 1.27)))\n")
    out.write("    )\n")

    # Value
    out.write("    (property Value\n")
    out.write(f'      (value "{node.part_number}")\n')
    out.write(f"      (at {placement.x + 2:.2f} {placement.y - 1:.2f} 0)\n")
    out.write("      (effects (font (size 1.27 1.27)))\n")
    out.write("    )\n")

    # Footprint
    fp = _footprint(node)
    out.write("    (property Footprint\n")
    out.write(f'      (value "{fp}")\n')
    out.write(f"      (at {placement.x:.2f} {placement.y:.2f} 0)\n")
    out.write("      (effects (font (size 1.27 1.27)) hide)\n")
    out.write("    )\n")

    # Pins
    for i, pin_name in enumerate(node.pins):
        pin_uuid = str(uuid.uuid4())
        px, py = _pin_position(placement, pin_name)
        out.write(f'    (pin "{pin_name}"\n')
        out.write(f'      (uuid "{pin_uuid}")\n')
        out.write(f"      (at {px:.2f} {py:.2f} 0)\n")
        out.write("    )\n")

    out.write("  )\n\n")


def _write_wire(
    out: TextIO,
    edge: CircuitEdge,
    src: SymbolPlacement,
    tgt: SymbolPlacement,
) -> None:
    """Write a wire connection between two pin positions."""
    sx, sy = _pin_position(src, edge.source_pin)
    tx, ty = _pin_position(tgt, edge.target_pin)

    # Orthogonal routing: go horizontal then vertical
    mid_x = (sx + tx) / 2

    out.write("  (wire\n")
    out.write(f"    (pts (xy {sx:.2f} {sy:.2f}) (xy {mid_x:.2f} {sy:.2f}))\n")
    out.write("  )\n")
    out.write("  (wire\n")
    out.write(f"    (pts (xy {mid_x:.2f} {sy:.2f}) (xy {mid_x:.2f} {ty:.2f}))\n")
    out.write("  )\n")
    out.write("  (wire\n")
    out.write(f"    (pts (xy {mid_x:.2f} {ty:.2f}) (xy {tx:.2f} {ty:.2f}))\n")
    out.write("  )\n")

    # Net label
    label_uuid = str(uuid.uuid4())
    out.write("  (net_label\n")
    out.write(f'    (value "{edge.net_name}")\n')
    out.write(f"    (at {mid_x:.2f} {sy:.2f} 0)\n")
    out.write(f'    (uuid "{label_uuid}")\n')
    out.write("    (effects (font (size 1.0 1.0)))\n")
    out.write("  )\n\n")


def _write_power_symbols(
    out: TextIO,
    graph: CircuitGraph,
    placements: list[SymbolPlacement],
) -> None:
    """Write VCC and GND power symbols at the top/bottom."""
    # Collect unique power rail voltages
    rail_voltages = set[float]()
    for rail in graph.power_rails:
        rail_voltages.add(rail.voltage)

    if not rail_voltages and not placements:
        return

    # Place power flags
    x_start = 20.0
    for i, voltage in enumerate(sorted(rail_voltages)):
        pwr_uuid = str(uuid.uuid4())
        x = x_start + i * 15.0
        out.write("  (power_port\n")
        out.write(f'    (name "VCC_{voltage:.1f}V")\n')
        out.write(f"    (at {x:.2f} 15.00 0)\n")
        out.write(f'    (uuid "{pwr_uuid}")\n')
        out.write("  )\n")

    # GND symbol
    gnd_uuid = str(uuid.uuid4())
    out.write("  (power_port\n")
    out.write(f'    (name "{graph.ground_net}")\n')
    out.write(f"    (at 20.00 {SHEET_HEIGHT_MM - 15:.2f} 0)\n")
    out.write(f'    (uuid "{gnd_uuid}")\n')
    out.write("  )\n\n")
